package io;

// Class to save a file as an Amiramesh file
// v 0.1 2005-12-03
// v 0.2 2005-12-04 - Corrected unsigned short and added date/time stamp
// v 0.3 2009-02-05 - Changed unsigned short to ushort

/* 
 * The first line of an AmiraMesh file should be a special comment including
 * the identifier AmiraMesh.  Moreover, if the tag ASCII is given in this line
 * all data arrays are stored in plain ascii text.  If the tag BINARY is
 * given, the data arrays are stored in IEEE big-endian binary format.  Note,
 * that the header section of an AmiraMesh file is always given as ascii text.
 * The statement define Nodes 4 defines a one-dimensional array of size 4.
 * Later on, this array can be referenced using the name Nodes.  Similarly, a
 * statement define Array 100 100 defines a two-dimensional array of size 100
 * x 100.  The actual kind of data stored per array element will be specified
 * later on.  The optional section Parameters allows the user to define
 * arbitrary additional parameters.  Each parameter consists of a name (like
 * Pi) and a value (like 3.1459).  Values may be one or multiple integer or
 * floating point numbers or a string.  Strings have to be quoted using a pair
 * of "-characters.  The optional section Materials allows the user to define
 * additional material information.  This is useful for finite element
 * applications.  The material section consists of a comma-separated list of
 * parameters just as in the Parameters section.  The statement Nodes {
 * float[3] Coordinates } = @1 specifies that for each element of the array
 * Nodes defined earlier three floating point numbers (floats) should be
 * stored.  These data are given the name Coordinates and a tag in this line
 * and will appear below as a tagged block with the marker @1.  Such data
 * markers must always begin with the letter @. Similar, the following lines
 * define additional data to be stored in the arrays called Nodes and
 * Tetrahedra.  The primitive data types must be one of byte, short, int,
 * float, double, or complex.  Vectors of primitive data types are allowed,
 * aggregate structs are not, however.  The statement Field { float Example }
 * = Linear(@8) defines a continuous scalar field with the name Example.  This
 * field will be generated by linear interpolation from the data values Values
 * defined on the nodes of the tetrahedral grid.  Other interpolation methods
 * include Constant(@X) and EdgeElem(@X).  After the marker @1 the coordinate
 * values of the grid are stored.  Likewise, the other data arrays are given
 * after their corresponding markers.  In case of a BINARY file the line
 * containing the marker is read up to the next new line character.  Then the
 * specified number of bytes is read in binary format.  It is assumed that
 * sizeof(short) is 2, sizeof(int) is 4, sizeof(float) is 4, sizeof(double) is
 * 8, and sizeof(complex) is 8.  Multidimensional arrays indexed via [k][j][i]
 * are read with i running fastest.
 *                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
 */
																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																								   

import ij.IJ;
import ij.ImagePlus;
import ij.WindowManager;
import ij.io.FileInfo;
import ij.io.ImageWriter;
import ij.io.SaveDialog;
import ij.measure.Calibration;
import ij.plugin.PlugIn;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.util.Date;

public class Amira_Writer implements PlugIn {

	private static final String plugInName = "Amira Writer";
	private static final String noImages = plugInName+"...\n"+ "No images are open.";
	private static final String supportedTypes =
		plugInName+"..."+				"Supported types:\n" +
				"\n" +
				"32-bit Grayscale float : FLOAT\n" +
				"(32-bit Grayscale integer) : LONG\n" +
				"16-bit Grayscale integer: INT\n" +
				"(16-bit Grayscale unsigned integer) : UINT\n"+
				"8-bit Grayscale : BYTE\n";
	
	private String imgTypeString=null;	
				
	public void run(String arg) {
		ImagePlus imp = WindowManager.getCurrentImage();
		if (imp == null) {
			IJ.showMessage(noImages);
			return;
		}
		imgTypeString=imgType(imp.getFileInfo().fileType);
		if (imgTypeString.equals("unsupported")) {
			IJ.showMessage(supportedTypes);
			return;
		}
		String name = arg;
		if (arg == null || arg.equals("")) {
			name = imp.getTitle();
		}
		
		SaveDialog sd = new SaveDialog(plugInName+"...", name, ".am");
		String file = sd.getFileName();
		if (file == null) return;
		String directory = sd.getDirectory();
		save(imp, directory, file);
	}

	public void save(ImagePlus imp, String directory, String file) {
		if (imp == null) {
			IJ.showMessage(noImages);
			return;
		}
		FileInfo fi = imp.getFileInfo();

		// Make sure that we can save this kind of image
		
		if(imgTypeString==null) {
			imgTypeString=imgType(fi.fileType);
			if (imgTypeString.equals("unsupported")) {
				IJ.showMessage(supportedTypes);
				return;
			}
		}		
		// Set the fileName stored in the file info record to the
		// file name that was passed in or chosen in the dialog box
		fi.fileName=file;
		
		// ie big endian as used by Amira on all platforms
		fi.intelByteOrder = false;

		// Put the calibration info into the FileInfo object that
		// will be passed down to the writeImage() function
		Calibration cal=imp.getCalibration();
		fi.pixelWidth=cal.pixelWidth; fi.pixelHeight=cal.pixelHeight;
		fi.pixelDepth=cal.pixelDepth; fi.unit=cal.getUnits();

		// Actually write out the image
		File f = new File(directory, file);
		try {
			writeImage(f,fi); 
		} catch (IOException e) {
			IJ.error("An error occured writing the file.\n \n" + e);
			IJ.showStatus("");
		}
	}
	void writeImage(File f, FileInfo fi) throws IOException {
		FileOutputStream out = new FileOutputStream(f);
		// First write out the full header
		writeHeader(fi,out);
		// Then the image data
		ImageWriter writer = new ImageWriter(fi);
		writer.write(out);
		out.close();	
		IJ.showStatus("Saved "+f.getName());
	}

	public static String imgType(int fiType) {
		switch (fiType) {
			case FileInfo.GRAY32_FLOAT:
				return "float";
			case FileInfo.GRAY32_INT:
				return "int";
			case FileInfo.GRAY16_SIGNED:
				return "short";	
			case FileInfo.GRAY16_UNSIGNED:
				return "ushort";
		
			case FileInfo.GRAY8:
				return "byte";
			default:
				return "unsupported";
		}
	}
	
	void writeHeader(FileInfo fi,FileOutputStream out_orig) throws IOException {
		/*
		# AmiraMesh 3D BINARY 2.0
		# CreationDate: Wed Nov 16 10:25:02 2005
		define Lattice 375 375 30
		Parameters {
			Content "375x375x30 byte, uniform coordinates",
			BoundingBox 0 168.78 0 168.78 0 72.5,
			CoordType "uniform"
		}
		Lattice { byte Data } @1
		# Data section follows
		@1
		*/
		Writer out
		   = new BufferedWriter(new OutputStreamWriter(out_orig));

		out.write("# AmiraMesh 3D BINARY 2.0\n");
		
		out.write("# Created by Amira_Writer at "+(new Date())+"\n\n");
//		cat("# Created by Write3DDensityToAmiraLattice - ",format(Sys.time(),usetz=T),"\n\n",file=fc)	

		out.write("define Lattice "+fi.width+" "+fi.height+" "+fi.nImages+"\n");
		out.write("Parameters { CoordType \"uniform\",\n");
		
		/* 
		 * note Amira's definition for the bounding box:
		 * the range of the voxel centres.
		 * So eval.points should correspond to the CENTRE of the
		 * voxels at which the density is evaluated
		 */
		out.write("\t# BoundingBox is xmin xmax ymin ymax zmin zmax\n");
		
		String bounds = "0 "+IJ.d2s(fi.pixelWidth*(fi.width-1),8)+
			" 0 "+IJ.d2s(fi.pixelHeight*(fi.height-1),8)+
			" 0 "+IJ.d2s(fi.pixelDepth*(fi.nImages-1),8);
		out.write("\t BoundingBox "+bounds+"\n");
		out.write("}\n\n");
		
		out.write("Lattice { "+imgTypeString+" ScalarField } = @1\n\n");
		out.write("@1\n");
		
		// Assume I should just flush rather than close
		out.flush();
		
	}
}
